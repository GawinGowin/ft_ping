# setitimer サンプルプログラム

## 概要

このプログラムは、Linuxの`setitimer()`システムコールを使用してバーチャルタイマー（ITIMER_VIRTUAL）の動作を示すサンプルです。親子プロセスを使用してCPU使用時間ベースのタイマー機能をデモンストレーションします。

## ファイル構成

- `setitimer_example.c` - メインプログラム

## プログラムの動作

### 主な機能

1. **バーチャルタイマーの設定**
   - `ITIMER_VIRTUAL`を使用してCPU時間ベースのタイマーを設定
   - タイマー間隔：500ミリ秒
   - プロセスがCPUを実際に使用している時間のみカウント

2. **プロセス分離**
   - `fork()`で子プロセスを作成
   - 子プロセスでCPU集約的な処理を実行
   - 親プロセスは子プロセスの終了を待機

3. **シグナルハンドリング**
   - `SIGVTALRM`シグナルを処理
   - タイマー発火時に`*`を出力してCPU使用状況を可視化

### プログラムフロー

1. `SIGVTALRM`シグナルハンドラを設定
2. 子プロセスを作成（`fork()`）
3. 子プロセス：
   - バーチャルタイマーを500ms間隔で設定
   - CPU集約的なループ処理を実行（`INT_MAX`まで）
   - タイマー発火時に`*`が出力される
4. 親プロセス：
   - 子プロセスの終了を待機（`wait()`）

## ビルドと実行

```bash
# ビルド
gcc -Wall -Wextra -Werror -std=c11 -o setitimer_example setitimer_example.c

# 実行
./setitimer_example
```

## 期待される出力

```
子プロセス開始
****************...（CPU使用に応じて*が表示）
子プロセス終了
親プロセス終了
```

## 技術的な詳細

### タイマーの種類

- **ITIMER_VIRTUAL**: プロセスがCPUを実際に使用している時間のみカウント
- **ITIMER_REAL**との違い: 実時間ではなくCPU時間ベース

### シグナルハンドリング

```c
void SigHandler(int p_signame) {
  printf("*");                    // 進捗表示
  fflush(stdout);                 // バッファをフラッシュ
  SetSignal(p_signame);           // シグナルハンドラを再設定
}
```

### タイマー設定

```c
struct itimerval value = {
  {0, 500 * MILLI_SEC},  // it_interval: 繰り返し間隔（500ms）
  {0, 500 * MILLI_SEC}   // it_value: 初回発火時間（500ms）
};
```

## 学習ポイント

1. **CPU時間の測定**: バーチャルタイマーによるCPU使用時間の監視
2. **プロセス間通信**: 親子プロセス間でのシグナル処理
3. **リアルタイム処理**: 定期的なイベント処理の実装方法
4. **システムリソース管理**: CPU集約的処理の監視

## 注意事項

- CPU集約的な処理のため、実行中はシステムリソースを消費します
- `Ctrl+C`で強制終了可能です
- プログラムは子プロセスでの処理完了後、自動的に終了します

## 関連する`ft_ping`プロジェクトへの応用

このサンプルは`ft_ping`プロジェクトでの以下の機能実装に参考になります：

- 定期的なICMPパケット送信のスケジューリング
- ネットワーク処理のタイムアウト管理
- リアルタイムな応答時間測定